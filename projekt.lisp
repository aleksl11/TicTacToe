(defun print-list (list)
    (loop for element in list
        do (print-sublist element)
    )
)

(defun print-sublist (sublist)
    (loop for element in sublist
        do (format t "|")
        (cond
            ((equal element 'X)
                (format t "~c[32mX~c[0m" #\ESC #\ESC)
            )
            ((equal element 'O)
                (format t "~c[31mO~c[0m" #\ESC #\ESC)
            )
            (t
                (princ element)
            )
        )
    )
    (format t "|~%")
)

(defvar *list* '((#\Space #\Space #\Space) (#\Space #\Space #\Space) (#\Space #\Space #\Space)))

(defun setlistvalue ()
  (setf (nth 0 (nth 0 *list*)) #\Space)
  (setf (nth 0 (nth 1 *list*)) #\Space)
  (setf (nth 0 (nth 2 *list*)) #\Space)
  (setf (nth 1 (nth 0 *list*)) #\Space)
  (setf (nth 1 (nth 1 *list*)) #\Space)
  (setf (nth 1 (nth 2 *list*)) #\Space)
  (setf (nth 2 (nth 0 *list*)) #\Space)
  (setf (nth 2 (nth 1 *list*)) #\Space)
  (setf (nth 2 (nth 2 *list*)) #\Space)
)

(defun get-valid-row ()
    (let ((row nil))
        (loop
            (format t "Enter a row (between 1 and 3): ")
            (finish-output)
            (setq row (read))
            (if (and (integerp row) (<= 1 row 3))
                (return row)
                (format t "Invalid input. Please enter a number between 1 and 3.~%")
            )
        )
    )
)

(defun get-valid-column ()
    (let ((column nil))
        (loop
            (format t "Enter a column (between 1 and 3): ")
            (finish-output)
            (setq column (read))
            (if (and (integerp column) (<= 1 column 3))
                (return column)
                (format t "Invalid input. Please enter a number between 1 and 3.~%")
            )
        )
    )
)

(defun player1 (message)
    (format t message)
    (loop
        (let ((column (get-valid-column))(row (get-valid-row)) )
            (format t "~%")
             (if (equal (nth (- column 1) (nth (- row 1) *list*)) #\Space)
                (progn (setf (nth (- column 1) (nth (- row 1) *list*)) 'X) (format t "~A[H~@*~A[J" #\escape) (return))
                (format t "The field is already taken~%")
            )
        )
    )
    (print-list *list*)
)

(defun player2 ()
    (format t "Player2's turn~%")
    (loop
        (let ((column (get-valid-column))(row (get-valid-row)) )
            (format t "~%")
            (if (equal (nth (- column 1) (nth (- row 1) *list*)) #\Space)
                (progn (setf (nth (- column 1) (nth (- row 1) *list*)) 'O) (format t "~A[H~@*~A[J" #\escape) (return))
                (format t "The field is already taken~%")
            )
        )
    )
    (print-list *list*)
)

(defun equal4 (x y z symbol)
    (and (equal x y) 
        (equal y z)
        (equal x symbol)
    )
)

(defun check-win(list symbol)
    (or
        ;;check columns
        (equal4 (nth 0 (nth 0 list)) (nth 0 (nth 1 list)) (nth 0 (nth 2 list)) symbol)
        (equal4 (nth 1 (nth 0 list)) (nth 1 (nth 1 list)) (nth 1 (nth 2 list)) symbol)
        (equal4 (nth 2 (nth 0 list)) (nth 2 (nth 1 list)) (nth 2 (nth 2 list)) symbol)
        ;;check rows
        (equal4 (nth 0 (nth 0 list)) (nth 1 (nth 0 list)) (nth 2 (nth 0 list)) symbol)
        (equal4 (nth 0 (nth 1 list)) (nth 1 (nth 1 list)) (nth 2 (nth 1 list)) symbol)
        (equal4 (nth 0 (nth 2 list)) (nth 1 (nth 2 list)) (nth 2 (nth 2 list)) symbol)
        ;;check diagonal
        (equal4 (nth 0 (nth 0 list)) (nth 1 (nth 1 list)) (nth 2 (nth 2 list)) symbol)
        (equal4 (nth 0 (nth 2 list)) (nth 1 (nth 1 list)) (nth 2 (nth 0 list)) symbol)
    )
)

(defun 2-player-game ()
    (print-list *list*)
    (let ((number-of-moves 0))
        (loop
            (player1 "Player1's turn~%")
            (if (check-win *list* 'X)
                (progn (format t "Player1 won!~%")
                (return))
            )
            (incf number-of-moves)
            (if (equal number-of-moves 9)
                (progn (format t "The game ended in a draw!~%")
                (return))
            )    
            (player2)
            (if (check-win *list* 'O)
                (progn (format t "Player2 won!~%")
                (return))
            )
            (incf number-of-moves)
        )
    )
)

(defun full-board ()
    (let ((number 0))
        (dotimes (i 3)
            (dotimes (j 3)
                (when (not(equal (nth i (nth j *list*)) #\Space))
                    (incf number)
                )
            )
        )
        (equal number 9)
    )
)

(defun minmax (current-player opponent)
    (cond 
    ((check-win *list* 'O)
        1
    )
    ((check-win *list* 'X)
        -1
    )
    ((full-board)
        0
    )
    (t
        (let ((scores nil)(result 0))
            (dotimes (i 3)
                (dotimes (j 3)
                    (when (equal (nth i (nth j *list*)) #\Space)
                        (setf (nth i (nth j *list*)) current-player)
                        (push (minmax opponent current-player) scores)
                        (setf (nth i (nth j *list*)) #\Space)
                    )
                )
            )    
            (if (equal current-player 'O)
                (setf result (apply #'max scores))
                (setf result (apply #'min scores))
            )
            result
        )
    )
    )
)

(defun ai-move ()
    (let ((score -10)(temp-score)(column)(row))
        (dotimes (i 3)
            (dotimes (j 3)
                (when (equal (nth i (nth j *list*)) #\Space)
                    (setf (nth i (nth j *list*)) 'O)
                    (setf temp-score (minmax 'X 'O))
                    (setf (nth i (nth j *list*)) #\Space)
                    (when (> temp-score score)
                        (setf column i)
                        (setf row j)
                        (setf score temp-score)
                    )
                    
                )
            )
        )
        (setf (nth column (nth row *list*)) 'O)
    )
    (format t "AI's move~%")
    (print-list *list*)
)

(defun 1-player-game ()
    (print-list *list*)
    (let ((number-of-moves 0))
        (loop
            (player1 "Your turn~%")
            (if (check-win *list* 'X)
                (progn (format t "You won!~%")
                (return))
            )
            (incf number-of-moves)
            (if (equal number-of-moves 9)
                (progn (format t "The game ended in a draw!~%")
                (return))
            )    
            (ai-move)
            (if (check-win *list* 'O)
                (progn (format t "You lost!~%")
                (return))
            )
            (incf number-of-moves)
        )
    )
)

(defun get-valid-choice ()
    (let ((choice nil))
        (loop
            (format t "Enter option number: ")
            (finish-output)
            (setq choice (read))
            (if (and (integerp choice) (<= 1 choice 3))
                (return choice)
                (format t "Invalid input. Please enter a number between 1 and 3.~%")
            )
        )
    )
)

(defun main-game()
    (loop
        (setlistvalue)
        (format t "~A[H~@*~A[J" #\escape)
        (format t "-------------~%")
        (format t "--TicTacToe--~%")
        (format t "-------------~%")
        (format t "1. Multiplayer game~%")
        (format t "2. Play against computer~%")
        (format t "3. Exit~%~%")
        (let ((choice (get-valid-choice)))
            (cond 
                ((equal choice 1)
                    (format t "~A[H~@*~A[J" #\escape)
                    (2-player-game)
                    (format t "Press Enter to continue...")
                    (finish-output)
                    (read-line)
                )
                ((equal choice 2)
                    (format t "~A[H~@*~A[J" #\escape)
                    (1-player-game)
                    (format t "Press Enter to continue...")
                    (finish-output)
                    (read-line)
                )
                ((equal choice 3)
                    (format t "~A[H~@*~A[J" #\escape)
                    (return)
                )
            )
        )
    )
)

(main-game)