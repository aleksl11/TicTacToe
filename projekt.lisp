(defun print-list (list)
    (loop for element in list
        do (print-sublist element)
    )
)

(defun print-sublist (sublist)
    (loop for element in sublist
        do (format t "|")
        (cond
            ((equal element 'X)
                (format t "~c[32mX~c[0m" #\ESC #\ESC)
            )
            ((equal element 'O)
                (format t "~c[31mO~c[0m" #\ESC #\ESC)
            )
            (t
                (princ element)
            )
        )
    )
    (format t "|~%")
)

(defvar *list* '((#\Space #\Space #\Space) (#\Space #\Space #\Space) (#\Space #\Space #\Space)))

(defun setlistvalue ()
  (setf (nth 0 (nth 0 *list*)) #\Space)
  (setf (nth 0 (nth 1 *list*)) #\Space)
  (setf (nth 0 (nth 2 *list*)) #\Space)
  (setf (nth 1 (nth 0 *list*)) #\Space)
  (setf (nth 1 (nth 1 *list*)) #\Space)
  (setf (nth 1 (nth 2 *list*)) #\Space)
  (setf (nth 2 (nth 0 *list*)) #\Space)
  (setf (nth 2 (nth 1 *list*)) #\Space)
  (setf (nth 2 (nth 2 *list*)) #\Space)
)

(defun get-valid-row ()
    (let ((row nil))
        (loop
            (format t "Enter a row (between 1 and 3): ")
            (finish-output)
            (setq row (read))
            (if (and (integerp row) (<= 1 row 3))
                (return row)
                (format t "Invalid input. Please enter a number between 1 and 3.~%")
            )
        )
    )
)

(defun get-valid-column ()
    (let ((column nil))
        (loop
            (format t "Enter a column (between 1 and 3): ")
            (finish-output)
            (setq column (read))
            (if (and (integerp column) (<= 1 column 3))
                (return column)
                (format t "Invalid input. Please enter a number between 1 and 3.~%")
            )
        )
    )
)

(defun player1 (message)
    (format t message)
    (loop
        (let ((column (get-valid-column))(row (get-valid-row)) )
            (format t "~%")
             (if (equal (nth (- column 1) (nth (- row 1) *list*)) #\Space)
                (progn (setf (nth (- column 1) (nth (- row 1) *list*)) 'X) (format t "~A[H~@*~A[J" #\escape) (return))
                (format t "The field is already taken~%")
            )
        )
    )
    (print-list *list*)
)

(defun player2 ()
    (format t "Player2's turn~%")
    (loop
        (let ((column (get-valid-column))(row (get-valid-row)) )
            (format t "~%")
            (if (equal (nth (- column 1) (nth (- row 1) *list*)) #\Space)
                (progn (setf (nth (- column 1) (nth (- row 1) *list*)) 'O) (format t "~A[H~@*~A[J" #\escape) (return))
                (format t "The field is already taken~%")
            )
        )
    )
    (print-list *list*)
)

(defun ai-move ()
    (if (equal (nth 1 (nth 1 *list*)) #\Space)
        (progn (setf (nth 1 (nth 1 *list*)) 'O) 
               (format t "~A[H~@*~A[J" #\escape)
        )
        (loop
            (let ((column (random 3))(row (random 3)) )
                (when (equal (nth column (nth row *list*)) #\Space)
                    (setf (nth column (nth row *list*)) 'O) 
                    (format t "~A[H~@*~A[J" #\escape) (return)
                )
            )
        )
    )
    (print-list *list*)
)

(defun equal3 (x y z)
    (and (equal x y) 
        (equal y z)
        (not (equal x #\Space))
    )
)

(defun check-win()
    (or
        ;;check columns
        (equal3 (nth 0 (nth 0 *list*)) (nth 0 (nth 1 *list*)) (nth 0 (nth 2 *list*)))
        (equal3 (nth 1 (nth 0 *list*)) (nth 1 (nth 1 *list*)) (nth 1 (nth 2 *list*)))
        (equal3 (nth 2 (nth 0 *list*)) (nth 2 (nth 1 *list*)) (nth 2 (nth 2 *list*)))
        ;;check rows
        (equal3 (nth 0 (nth 0 *list*)) (nth 1 (nth 0 *list*)) (nth 2 (nth 0 *list*)))
        (equal3 (nth 0 (nth 1 *list*)) (nth 1 (nth 1 *list*)) (nth 2 (nth 1 *list*)))
        (equal3 (nth 0 (nth 2 *list*)) (nth 1 (nth 2 *list*)) (nth 2 (nth 2 *list*)))
        ;;check diagonal
        (equal3 (nth 0 (nth 0 *list*)) (nth 1 (nth 1 *list*)) (nth 2 (nth 2 *list*)))
        (equal3 (nth 0 (nth 2 *list*)) (nth 1 (nth 1 *list*)) (nth 2 (nth 0 *list*)))
    )
)

(defun 2-player-game ()
    (print-list *list*)
    (let ((number-of-moves 0))
        (loop
            (player1 "Player1's turn~%")
            (if (check-win)
                (progn (format t "Player1 won!~%")
                (return))
            )
            (incf number-of-moves)
            (if (equal number-of-moves 9)
                (progn (format t "The game ended in a draw!~%")
                (return))
            )    
            (player2)
            (if (check-win)
                (progn (format t "Player2 won!~%")
                (return))
            )
            (incf number-of-moves)
        )
    )
)

(defun 1-player-game ()
    (print-list *list*)
    (let ((number-of-moves 0))
        (loop
            (player1 "Your turn~%")
            (if (check-win)
                (progn (format t "You won!~%")
                (return))
            )
            (incf number-of-moves)
            (if (equal number-of-moves 9)
                (progn (format t "The game ended in a draw!~%")
                (return))
            )    
            (ai-move)
            (if (check-win)
                (progn (format t "You lost!~%")
                (return))
            )
            (incf number-of-moves)
        )
    )
)

(defun get-valid-choice ()
    (let ((choice nil))
        (loop
            (format t "Enter option number: ")
            (finish-output)
            (setq choice (read))
            (if (and (integerp choice) (<= 1 choice 3))
                (return choice)
                (format t "Invalid input. Please enter a number between 1 and 3.~%")
            )
        )
    )
)

(defun main-game()
    (loop
        (setlistvalue)
        (format t "~A[H~@*~A[J" #\escape)
        (format t "-------------~%")
        (format t "--TicTacToe--~%")
        (format t "-------------~%")
        (format t "1. Multiplayer game~%")
        (format t "2. Play against computer~%")
        (format t "3. Exit~%~%")
        (let ((choice (get-valid-choice)))
            (cond 
                ((equal choice 1)
                    (format t "~A[H~@*~A[J" #\escape)
                    (2-player-game)
                    (format t "Press Enter to continue...")
                    (finish-output)
                    (read-line)
                )
                ((equal choice 2)
                    (format t "~A[H~@*~A[J" #\escape)
                    (1-player-game)
                    (format t "Press Enter to continue...")
                    (finish-output)
                    (read-line)
                )
                ((equal choice 3)
                    (return)
                )
            )
        )
    )
)

(main-game)